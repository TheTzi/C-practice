#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>

//算术操作符
//+    -   *   /   %
//1. 除了 % 操作符之外，其他的几个操作符可以作用于整数和浮点数。
//2. 对于 / 操作符如果两个操作数都为整数，执行整数除法。而只要有浮点数执行的就是浮点数除
//法。
//3. % 操作符的两个操作数必须为整数。返回的是整除之后的余数。
//除法 取模
int main()
{
	int a = 5 / 2;//商2 余1
	return 0;
}

//移位操作符
//<< 左移操作符 左移一位相当于乘2
//左移操作符 移位规则：
//左边抛弃、右边补0
//>> 右移操作符
//右移操作符 移位规则：
//首先右移运算分两种：
//1. 逻辑移位 左边用0填充，右边丢弃
//2. 算术移位 左边用原该值的符号位填充，右边丢弃
//警告⚠ ： 对于移位运算符，不要移动负数位，这个是标准未定义的。 例如：
//int num = 10;
//num >> -1;//error

//位操作符
//& //按位与
//| //按位或
//^ //按位异或
//注：他们的操作数必须是整数。
int main()
{
	int num1 = 1;
	int num2 = 2;
	num1& num2;
	num1 | num2;
	num1^ num2;
	return 0;
}

//不能创建临时变量（第三个变量），实现两个数的交换。
int main()
{
	int a = 10;
	int b = 20;
	a = a ^ b;
	b = a ^ b;
	a = a ^ b;
	printf("a = %d b = %d\n", a, b);
	return 0;
}

//求一个整数存储在内存中的二进制中1的个数

//对于正数(补码就是源码)

int main()
{
	int num = 10;
	int count = 0;
	while (num)
	{
		if (num % 2 == 1)
			count++;
		num = num / 2;
	}
	printf("%d\n", count);
	return 0;
}
  
//包含负数的统计

int main()
{
	int num = -1;
	int count = 0;
	int i = 0;
	for(i=0; i<32;i++)
	{
		if (((num >> i)&1) == 1)
			count++;
	}
	printf("%d\n", count);
	return 0;
}
//第三种解法
int main()
{
	int num = -1;
	int i = 0;
	int count = 0;//计数
	while (num)
	{
		count++;
		num = num & (num - 1);
	}
	printf("二进制中1的个数 = %d\n", count);
	return 0;
}


//赋值操作符
//赋值操作符是一个很棒的操作符，他可以让你得到一个你之前不满意的值。
//也就是你可以给自己重新赋值。
//int weight = 120;//体重
//weight = 89;//不满意就赋值
//double salary = 10000.0;
//salary = 20000.0;//使用赋值操作符赋值。
//赋值操作符可以连续使用，比如：
//int a = 10;
//int x = 0;
//int y = 20; a = x = y + 1;//连续赋值
//这样的代码感觉怎么样？
//那同样的语义，你看看：
//x = y + 1; a = x;
//这样的写法是不是更加清晰爽朗而且易于调试

//复合赋值符
//+=
//-=
//*=
///=
//%=
//>>=
//<<=
//&=
//|=
//^=
//int x = 10; x = x + 10; x += 10;//复合赋值
//其他运算符一样的道理。这样写更加简洁。

//单目操作符
//!逻辑反操作
//- 负值
//+ 正值
//& 取地址
//sizeof      操作数的类型长度（以字节为单位）
//~对一个数的二进制按位取反
//--          前置、后置--
//++前置、后置++
//* 间接访问操作符(解引用操作符) (类型)       强制类型转换

int main()
{
	int a = -10;
	int* p = NULL;
	printf("%d\n", !2);
	printf("%d\n", !0);
	a = -a;
	p = &a;
	printf("%d\n", sizeof(a));
	printf("%d\n", sizeof(int));
	printf("%d\n", sizeof a);//这样写行不行？y
	printf("%d\n", sizeof int);//这样写行不行？n
return 0; 
}

int main()
{
	int a = 0;
	if (!a)
	{
		printf("hao");
	}
}

//sizeof和数组
void test1(int arr[])
{
	printf("%d\n", sizeof(arr));//(2)
}
void test2(char ch[])
{
	printf("%d\n", sizeof(ch));//(4)
}
int main()
{
	int arr[10] = { 0 };
	char ch[10] = { 0 };
	printf("%d\n", sizeof(arr));//(1)
	printf("%d\n", sizeof(ch));//(3)
	test1(arr);
	test2(ch);
	return 0;
}

////++和--运算符
////前置++和--
// //前置++和--：
//#include <stdio.h>
int main()
{
	int a = 10;
	int x = ++a;
	//先对a进行自增，然后对使用a，也就是表达式的值是a自增之后的值。x为11。
	int y = --a;
	//先对a进行自减，然后对使用a，也就是表达式的值是a自减之后的值。y为10;
	return 0;
}
//
////后置++和--
//#include <stdio.h>
int main()
{
	int a = 10;
	int x = a++;
	//先对a先使用，再增加，这样x的值是10；之后a变成11；
	int y = a--;
	//先对a先使用，再自减，这样y的值是11；之后a变成10；
	return 0;
}

int main()
{
	int arr[10] = { 0 };
	int a = 10;
	int* p = &a; //取地址操作符
	*p; //解引用操作符 就是a 指针大小-4字节32位平台 8/64
	sizeof a;
	sizeof(int);//后面是类型就不能省略括号
	sizeof(char*);
	sizeof(arr);
	sizeof(int[10]);

	return 0;
}

//~对一个数的二进制按位取反
int main()
{
	int a = 0;
	//00000000000000000000000000000000
	//11111111111111111111111111111111 -补码
	//11111111111111111111111111111110 -反码
	//10000000000000000000000000000001 -原码
	printf("%d\n",~a);
	return 0;
}

//置 11<->15
int main()
{
	int a = 11;
	a = a | (1 << 2);
	printf("%d\n", a);

	//00000000000000000000000000001011
	//00000000000000000000000000000100
	//1<<2;
	//00000000000000000000000000000001
	//0000000000000000000000  0000001111

	a = a & (~(1 << 2));
	printf("%d\n", a);
	//1111
	//1011 &
	//1011
	int a = 11;
	return 0;
}

//关系操作符
//>
//>=
//<
//	<=
//	!=   用于测试“不相等”
//	== 用于测试“相等”

//逻辑操作符
//&&     逻辑与
//|| 逻辑或
//区分逻辑与和按位与 区分逻辑或和按位或
//1&2----->0 1&&2---->1 1|2----->3 1||2---->1
//360笔试题
int main()
{
	int i = 0, a = 0, b = 2, c = 3, d = 4;
	i = a++ && ++b && d++;
	//i = a++||++b||d++;
	printf("a = %d\n b = %d\n c = %d\nd = %d\n", a, b, c, d);
	return 0; 
}
//程序输出的结果是什么？

//条件操作符
//exp1 ? exp2 : exp3
//1.
if (a > 5)
b = 3;
else
b = -3;
//转换成条件表达式，是什么样？b=(a>5?3:-3);
//2.使用条件表达式实现找两个数中较大值。

//逗号表达式
//exp1, exp2, exp3, …expN
//逗号表达式，就是用逗号隔开的多个表达式。 逗号表达式，从左向右依次执行。
//整个表达式的结果是最后一个表达式的结果。
//代码1
int a = 1;
int b = 2;
int c = (a > b, a = b + 10, a, b = a + 1);//逗号表达式
c是多少？
//代码2
if (a = b + 1, c = a / 2, d > 0)
//代码3 a = get_val();
count_val(a);
while (a > 0) {
	//业务处理
	a = get_val();
	count_val(a);
}
//如果使用逗号表达式，改写：
//while (a = get_val(), count_val(a), a > 0) {
//	//业务处理
//}

//下标引用、函数调用和结构成员
//1.[ ] 下标引用操作符
//操作数：一个数组名 + 一个索引值

int arr[10];//创建数组
arr[9] = 10;//实用下标引用操作符。
//[] 的两个操作数是arr和9

//2.( ) 函数调用操作符 接受一个或者多个操作数：
//第一个操作数是函数名，剩余的操作数就是传递给函数的参数
//void test1()
 //{
 //printf("hehe\n");
 //}
 //void test2(const char* str)
 //{
	// printf("%s\n", str);
 //}
 //int main()
 //{
	// test1();            //实用（）作为函数调用操作符。
	// test2("hello bit.");//实用（）作为函数调用操作符。
	// return 0;
 //}
//

//3.访问一个结构的成员
//.结构体变量.成员名
//->结构体指针->成员名

//struct Stu
//{
//	//成员变量
//	char name[10];
//	int age;
//	char sex[5];
//	double score;
//};
//void set_age1(struct Stu stu) {
//	stu.age = 18;
//}
//void set_age2(struct Stu* pStu) {
//	pStu->age = 18;//结构成员访问
//}
//int main()
//{
//	//使用struct stu这个类型创建了一个学生对象s1，并初始化
//	struct Stu stu = {"王子","15","女"};
//	printf("%s\n", stu.name);
//	printf("%d\n", stu.age);//结构体变量.成员名
//	printf("%s\n", stu.sex);
//	struct Stu* pStu = &stu;//结构成员访问
//
//	stu.age = 20;//结构成员访问
//	set_age1(stu);
//
//	//结构体指针->成员名
//	pStu->age = 20;//结构成员访问 = (*pStu).age
//	set_age2(pStu);
//	return 0;
//}

//表达式求值
//表达式求值的顺序一部分是由操作符的优先级和结合性决定。
//同样，有些表达式的操作数在求值的过程中可能需要转换为其他类型。

//隐式类型转换
//C的整型算术运算总是至少以缺省整型类型的精度来进行的。
//为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，
//这种转换称为整型提升。

//实例1
char a, b, c;
...
a = b + c;
//b和c的值被提升为普通整型，然后再执行加法运算。
//加法运算完成之后，结果将被截断，然后再存储于a中。

//整形提升是按照变量的数据类型的符号位来提升的
//负数的整形提升
char c1 = -1;
//变量c1的二进制位(补码)中只有8个比特位：
//1111111
//因为 char 为有符号的 char
//所以整形提升的时候，高位补充符号位，即为1
//提升之后的结果是：
//11111111111111111111111111111111

////正数的整形提升
//char c2 = 1;
//变量c2的二进制位(补码)中只有8个比特位：
//00000001
//因为 char 为有符号的 char
//所以整形提升的时候，高位补充符号位，即为0
//提升之后的结果是：
//00000000000000000000000000000001
////无符号整形提升，高位补0

//整形提升的例子:
//实例1
int main()
{
	char a = 0xb6;
	short b = 0xb600;
	int c = 0xb6000000;
	if (a == 0xb6)
		printf("a");
	if (b == 0xb600)
		printf("b");
	if (c == 0xb6000000)
		printf("c");
	return 0;
}//c
//实例1中的a,b要进行整形提升,但是c不需要整形提升 a,b整形提升之后,变成了负数,所以表达式
//a == 0xb6, b == 0xb600 的结果是假, 但是c不发生整形提升, 则表达式 c == 0xb6000000 的结果是真

int main()
{
	char c = 1;
	printf("%u\n", sizeof(c));
	printf("%u\n", sizeof(+c));
	printf("%u\n", sizeof(!c));
	return 0;
}
//实例2中的, c只要参与表达式运算, 就会发生整形提升, 表达式 + c, 就会发生提升, 所以 sizeof(+c) 是4个字
//节.
//表达式 - c 也会发生整形提升, 所以 sizeof(-c) 是4个字节, 但是 sizeof(c), 就是1个字节.

//算数转换
//如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类型
//否则操作就无法进行。下面的层次体系称为寻常算术转换。

//long double
//double
//float
//unsigned long int
//long int
//unsigned int
//int
//如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运
//算。
//警告： 但是算术转换要合理，要不然会有一些潜在的问题。
float f = 3.14;
int num = f;//隐式转换，会有精度丢失

//操作符的属性
//两个相邻的操作符先执行哪个？取决于他们的优先级。
//如果两者的优先级相同，取决于他们的结合性。
//求复杂表达式有三分影响因素
//操作符优先级
//操作符结合性
//是否控制求值顺序

//一些问题表达式
//表达式的求值部分由操作符的优先级决定。
//表达式1 a*b + c*d + e*f

//注释：代码1在计算的时候，由于比+的优先级高，只能保证，的计算是比+早
//但是优先级并不能决定第三个* 比第一个 + 早执行。

//所以表达式的计算机顺序就可能是：
//a* b c* d a* b + c * d e * f a * b + c * d + e * f
//或者：
//a * b c * d e * f
//a* b + c * d a * b + c * d + e * f

//表达式2 c + --c;
//注释：同上，操作符的优先级只能决定自减--的运算在 + 的运算的前面，但是我们并没有办法得
//知， + 操作符的左操作数的获取在右操作数之前还是之后求值，所以结果是不可预测的，是有歧义
//的。

//代码3-非法表达式
int main()
{
	int i = 10;
	i = i-- - --i * (i = -3) * i++ + ++i;
	printf("i = %d\n", i);
	return 0;
}
//表达式3在不同编译器中测试结果都不同

//代码4
int fun()
{
	static int count = 1;
	return ++count;
}
int main()
{
	int answer;
	answer = fun() - fun() * fun();
	printf("%d\n", answer);//输出多少？
	return 0;
}
//虽然在大多数的编译器上求得结果都是相同的。
//但是上述代码 answer = fun() - fun() * fun(); 中我们只能通过操作符的优先级得知：
//先算乘法，再算减法。
//函数的调用先后顺序无法通过操作符的优先级确定。

//代码5
#include <stdio.h>
int main()
{
	int i = 1;
	int ret = (++i) + (++i) + (++i);
	printf("%d\n", ret);
	printf("%d\n", i);
	return 0;
}

//这段代码中的第一个 + 在执行的时候，第三个++是否执行，这个是不确定的
//因为依靠操作符的优先级和结合性是无法决定第一个 + 和第三个前置 ++ 的先后顺序。
//总结：我们写出的表达式如果不能通过操作符的属性确定唯一的计算路径
//那这个表达式就是存在问题的。








