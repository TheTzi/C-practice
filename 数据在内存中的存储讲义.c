#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>
//int main()
//{
//	int a = 20; //4
//	float f = 10.0; //4
//	int c = -10;
//
//	return 0;
//}

//数据类型介绍

//基本的内置类型：
//char        //字符数据类型
//short       //短整型
//int         //整形
//long        //长整型
//long long   //更长的整形
//float       //单精度浮点数
//double      //双精度浮点数
 
//C语言有没有字符串类型？

//以及他们所占存储空间的大小。 类型的意义：
//1. 使用这个类型开辟内存空间的大小（大小决定了使用范围）。
//2. 如何看待内存空间的视角。

//类型的基本归类：

//整形家族：
//char
//unsigned char
//signed char
//short
//unsigned short[int]
//signed short[int]
//int
//unsigned int
//signed int
//long
//unsigned long[int]
//signed long[int]

//浮点数家族：
//float
//double

//构造类型：
//> 数组类型
//> 结构体类型 struct
//> 枚举类型 enum
//> 联合类型 union

//指针类型
//int *pi;
//char* pc;
//float* pf;
//void* pv;

//空类型：
//void 表示空类型（无类型）
//通常应用于函数的返回类型、函数的参数、指针类型。

//整形在内存中的存储
//我们之前讲过一个变量的创建是要在内存中开辟空间的。空间的大小是根据不同的类型而决定的。

//原码、反码、补码
//计算机中的有符号数有三种表示方法，即原码、反码和补码。
//三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位
//三种表示方法各不相同。
//原码
//直接将二进制按照正负数的形式翻译成二进制就可以。
//反码
//将原码的符号位不变，其他位依次按位取反就可以得到了。
//补码
//反码 + 1就得到补码

//正数的原、反、补码都相同。
//对于整形来说：数据存放内存中其实存放的是补码。
//为什么呢？
//在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理； 同
//时，加法和减法也可以统一处理（CPU只有加法器）此外，补码与原码相互转换，其运算过程是相同的，不需
//要额外的硬件电路。

//大小端介绍
//什么大端小端：
//大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；
//小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位, ，保存在内存的高地址中。
//为什么有大端和小端：
//为什么会有大小端模式之分呢？这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一
//个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具
//体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字
//节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。
//例如一个 16bit 的 short 型 x ，在内存中的地址为 0x0010 ， x 的值为 0x1122 ，那么 0x11 为高字节， 0x22
//为低字节。对于大端模式，就将 0x11 放在低地址中，即 0x0010 中， 0x22 放在高地址中，即 0x0011 中。小
//端模式，刚好相反。我们常用的 X86 结构是小端模式，而 KEIL C51 则为大端模式。很多的ARM，DSP都为小
//端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。

//百度2015年系统工程师笔试题

//请简述大端字节序和小端字节序的概念，设计一个小程序来判断当前机器的字节序。（10分）
////代码1
//#include <stdio.h>
//int check_sys()
//{
//	int i = 1;
//	return (*(char*)&i);
//}
//int main()
//{
//	int ret = check_sys();
//	if (ret == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}
////代码2
//int check_sys()
//{
//	union
//	{
//		int i;
//		char c;
//	}un;
//	un.i = 1;
//	return un.c;
//}

//int main()
//{
//	int a = 1;
//	char* p = (char*)&a;
//	if (a == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}
//
////练习
//
//1.
////输出什么？
//#include <stdio.h>
//int main()
//{
//	char a = -1;
//	10000001
//	11111110
//	11111111
// 
//	signed char b = -1;
//	10000001
//	11111110
//	11111111
// 
//	unsigned char c = -1; //放的都是补码 内容一样
//	11111111
// 
//	printf("a=%d,b=%d,c=%d", a, b, c); //拿出来就不一样了
//	a 整型提升
//	11111111 11111111 11111111 11111111 补码
//	11111111 11111111 11111111 11111110 反码
//  10000000 00000000 00000000 00000001 原码 打印的是原码 -1
//  
//	b 同理打印-1
// 
//  c 整型提升 无符号数默认补0
//	00000000 00000000 00000000 11111111 高位0表示正数 原反补码相同 直接打印255
//
//	return 0;
//}
//下面程序输出什么？
//2.
//#include <stdio.h>
//int main()
//{
//	char a = -128;
//	10000000 00000000 00000000 10000000
//  11111111 11111111 11111111 01111111
//  11111111 11111111 11111111 10000000
//  10000000
//	11111111 11111111 11111111 10000000 //补码
//	printf("%u\n", a); 按照无符号数进行打印 高位1不代表负号 原反补码相同
//	return 0;
//}
//3.
//#include <stdio.h>
//int main()
//{
//	char a = 128;
//	printf("%u\n", a);
//	return 0;
//}
//4.
//int i = -20;
//unsigned  int  j = 10;
// i
// 10000000 00000000 00000000 00010100
// 11111111 11111111 11111111 11101011
// 11111111 11111111 11111111 11101100
// j
// 00000000 00000000 00000000 00001010
// i+j
// 11111111 11111111 11111111 11110110
// 11111111 11111111 11111111 11110101
// 10000000 00000000 00000000 00001010
//printf("%d\n", i + j);
//按照补码的形式进行运算，最后格式化成为有符号整数

//5.
int main()
{
	unsigned int i;
	for (i = 9; i >= 0; i--) 
	{
		printf("%u\n", i);
	}
	return 0;
}


//6.
//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	printf("%d", strlen(a));
//	return 0;
//}255

//7.
//#include <stdio.h>
//unsigned char i = 0;
//int main()
//{
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hello world\n");
//	}
//	return 0;
//} 死循环

//浮点型在内存中的存储
//常见的浮点数：
//3.14159 1E10 浮点数家族包括： float、double、long double 类型。 浮点数表示的范围：float.h中定义
//浮点数存储的例子：

int main()
{
	int n = 9;
	//00000000 00000000 00000000 00001001 -原反补码相同
	//0 00000000 000000000000000000001001
	float* pFloat = (float*)&n;
	printf("n的值为：%d\n", n);
	printf("*pFloat的值为：%f\n", *pFloat);
	//(-1)^0 * 0.000000|打印到这00000000000000000000001001 * 2^-126
	*pFloat = 9.0;
	//1001.0
	//1.001*2^3
	//(-1)^0 * 1.001 * 2^3 //(3+127)
	//0 10000010 00100000000000000000000

	printf("num的值为：%d\n", n);
	//01000001000100000000000000000000//正数 原反补码相同
	printf("*pFloat的值为：%f\n", *pFloat);//9.0
	return 0;
}

//num 和* pFloat 在内存中明明是同一个数，为什么浮点数和整数的解读结果会差别这么大？ 要理解这个结果，一定
//要搞懂浮点数在计算机内部的表示方法。
//详细解读：
//根据国际标准IEEE（电气和电子工程协会） 754，任意一个二进制浮点数V可以表示成下面的形式：
//(-1) ^ S * M * 2 ^ E
//(-1) ^ s表示符号位，当s = 0，V为正数；当s = 1，V为负数。
//M表示有效数字，大于等于1，小于2。
//2 ^ E表示指数位。

//举例来说： 十进制的5.0，写成二进制是 101.0 ，相当于 1.01×2 ^ 2 。 那么，按照上面V的格式，可以得出s = 0，
//M = 1.01，E = 2。
//十进制的 - 5.0，写成二进制是 - 101.0 ，相当于 - 1.01×2 ^ 2 。那么，s = 1，M = 1.01，E = 2。
//IEEE 754规定： 对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。
//对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。

//其余说明见讲义9-8
